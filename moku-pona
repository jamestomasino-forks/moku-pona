#!/usr/bin/env perl
# Copyright (C) 2018  Alex Schroeder <alex@gnu.org>

# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <http://www.gnu.org/licenses/>.

use Modern::Perl;
use IO::Socket::IP;
use URI;

# This is our directory. Every gopher URL we subscribe to will generate a file
# in this directory, eg. 'alexschroeder.ch:70'. We need this because we need to
# detect changes. We cannot rely on feeds.
our $data_dir = ($ENV{HOME} || $ENV{LOGDIR}) . '/.moku-pona';

# This is a gopher map listing all the pages being watched whih means that you
# can view using a gopher client. Or you can add it to your gopher site for
# others to see.
our $site_list = $data_dir . '/sites.txt';

# This is the generated list with all the updates.
our $updated_list = $data_dir . '/updates.txt';

sub query_gopher {
  my $selector = shift;
  my $host = shift;
  my $port = shift;
  
  # create client
  my $socket = IO::Socket::IP->new(
    PeerHost => $host,
    PeerPort => $port,
    Type     => SOCK_STREAM, )
      or die "Cannot construct client socket to $host:$port: $@\n";

  $socket->print("$selector\r\n");
  shutdown($socket, 1);
  local $/ = undef; # slurp
  return <$socket>;
}

sub load_site {
  my $file = shift;
  return [] if not -f $site_list;
  open(my $fh, "<:encoding(UTF-8)", $site_list)
      or die "Cannot read $site_list: $!\n";
  # only allow item type 1: "menu"
  local $/ = "\r\n";
  my @lines = grep(/^1/, <$fh>);
  chomp(@lines);
  return \@lines;
}

sub load_file {
  my $file = shift;
  return "" if not -f $file;
  open(my $fh, "<:encoding(UTF-8)", $file)
      or die "Cannot read $file: $!\n";
  local $/ = undef; # slurp
  return <$fh>;
}

sub save_file {
  my $file = shift;
  my $data = shift;
  mkdir $data_dir unless -d $data_dir;
  open(my $fh, ">:encoding(UTF-8)", $file)
      or die "Cannot write $file: $!\n";
  print $fh $data;
}

sub do_add {
  my $str = shift;
  $str = "gopher://" . $str unless $str =~ /:\/\//;
  my $uri = URI->new($str);
  if (not $uri->scheme or $uri->scheme !~ /^gophers?$/) {
    warn("Only gopher URLs allowed\n");
    return;
  }
  my $name = shift||$uri;
  my $path = $uri->path;
  $path = substr($path, 1) if substr($path, 0, 1) eq "/";
  my $type = $path ? substr($path, 0, 1) : "1";
  my $selector = $path ? substr($path, 1) : "";
  my $line = join("\t", $type . $name, $selector,
		  $uri->host, $uri->port||70);
  my $site = load_site();
  if (not grep(/^$line$/, @$site)) {
    push(@$site, $line);
  } else {
    warn("$uri already exists in $site_list\n");
  }
  save_file($site_list, join("\r\n", @$site, ""));
}

sub do_cleanup {
  my $confirm = shift||'' eq '--confirm';
  # get a hash map telling us the cache files we expect based on our sites
  my $site = load_site();
  my %caches = map {
    my ($desc, $selector, $host, $port) = split(/\t/, substr($_, 1));
    $port += 0;
    $selector =~ s/\//-/g;
    "$data_dir/$host-$port-$selector.txt" => 1;
  } @$site;
  # get a list of text files in the directory
  opendir(my $dh, $data_dir)
      or die "Cannot read $data_dir: $!\n";
  my @files = map { "$data_dir/$_" }
      grep { /\.txt$/ && -f "$data_dir/$_" }
      readdir($dh);
  closedir($dh);
  for my $file (@files) {
    next if $file eq $site_list;
    next if $file eq $updated_list;
    next if $caches{$file};
    if ($confirm) {
      unlink $file;
    } else {
      print "trash $file\n";
    }
  }
  if (!$confirm) {
    print "\n";
    print "Use moku-pona cleanup --confirm to do it.\n";
  }
}

sub add_update {
  my $line = shift;
  my ($sec, $min, $hour, $mday, $mon, $year) = gmtime(); # UTC
  my $date = sprintf('%4d-%02d-%02d', $year + 1900, $mon + 1, $mday);
  my @lines;
  if (-f $updated_list) {
    open(my $fh, "<:encoding(UTF-8)", $updated_list)
	or die "Cannot read $updated_list: $!\n";
    local $/ = "\r\n";
    @lines = <$fh>; # includes info items
    chomp(@lines);
  }
  my $found = 0;
  # first, let's see if we already ran today
  for (my $i = 0; $i < @lines; $i++) {
    if ($lines[$i] =~ /^i$date\t/) {
      splice(@lines, $i + 1, 0, $line);
      $found = $i + 1;
      last;
    }
  }
  # if we didn't find the date, add it to the front but skip info lines that
  # don't look like dates
  if (not $found) {
    my @block;
    push(@block, "i$date\t\t\t");
    push(@block, $line);
    push(@block, "i\t\t\t"); # empty line
    for (my $i = 0; $i < @lines; $i++) {
      if ($lines[$i] =~ /^i$date\t/) {
	$found = $i - 1;
	last;
      }
    }
    splice(@lines, $found, 0, @block);
    $found += @block;
  }
  # and remove any past mentions
  for (my $i = $found + 1; $i < @lines; $i++) {
    if ($lines[$i] eq $line) {
      splice(@lines, $i, 1);
      last;
    }
  }
  # and remove dates that have no more entries
  for (my $i =0; $i < @lines; ) {
    if ($lines[$i] =~ /^i\d\d\d\d-\d\d-\d\d\t/
	and $lines[$i+1] =~ /^i\t/) {
      splice(@lines, $i, 2);
    } else {
      $i++;
    }
  }
  # save
  save_file($updated_list, join("\r\n", @lines, ""));
}

sub do_update {
  my $site = load_site();
  for my $line (@$site) {
    # skip item type
    my ($desc, $selector, $host, $port) = split(/\t/, substr($line, 1));
    $port += 0;
    print("Fetching $desc...");
    my $new = query_gopher($selector, $host, $port);
    $selector =~ s/\//-/g;
    my $cache = "$data_dir/$host-$port-$selector.txt";
    my $old = load_file($cache);
    if ($new ne $old) {
      print("updated\n");
      add_update($line);
      save_file($cache, $new);
    } else {
      print("unchanged\n");
    }
  }
}

sub do_list {
  my $site = load_site();
  print("Subscribed items in $site_list:\n");
  print("none\n") unless @$site;
  for my $line (@$site) {
    # skip item type
    my ($desc, $selector, $host, $port) = split(/\t/, substr($line, 1));
    if ($selector) {
      print(qq{moku-pona add $host:$port/1$selector "$desc"\n});
    } else {
      print(qq{moku-pona add $host:$port "$desc"\n});
    }
  }
}

sub do_help {
  print <<"EOF";
moku-pona add gopher-url

  This adds a gopher URL to the list of subscribed items. These are stored in
  $site_list.

moku-pona list

  This lists all the subscribed items.

moku-pona cleanup [--confirm]

  This deletes all the cached pages that we are no longer subscribed to. These
  are stored in $data_dir.

moku-pona update

  This updates all the subscribed items and generates a new local gopher menu
  for you to visit. This menu is available as $updated_list.

EOF
}

sub main {
  my $command = shift(@ARGV) || "help";
  if ($command eq "add") { do_add(@ARGV) }
  elsif ($command eq "list") { do_list() }
  elsif ($command eq "cleanup") { do_cleanup(@ARGV); }
  elsif ($command eq "update") { do_update() }
  else { do_help() }
}

main() if $0 =~ /\bmoku-pona$/;

1;
